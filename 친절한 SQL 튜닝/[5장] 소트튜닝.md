# [5장] 소트튜닝

### 5.1.1 소트 수행 과정

- 소트는 기본적으로 PGA에 할당된 Sort Area에서 이루어 진다. ( Sort Area → temp 테이블스페이스)
    1. 메모리 소트(인터널 소트) : 메모리내에서 정렬이 완료된 것.
    2. 디스크 소트(익스터널 소트) : 할당된 메모리 이외에 디스크 공간까지 사용하는 경우
        - 임시 세그먼트 장소에서 소트런 → 머지 과정을 거친다.
- 메모리 뿐만 아니라 CPU영역까지 집약적이다. → 쿼리 성능을 좌우하는 매우 중요한 요소.
- 부분범위 처리를 불가능하게 함으로써 OLTP환경에서 앱 성능을 저하시키는 주 요인

### 5.1.2 소트 오퍼레이션

1. Sort Aggregate
- 전체 로우를 대상으로 집계를 수행한다. → Sort Area를 이용
2. Sort Order By
- 그림 5-1 참조.
3. Sort Group By
- Hash Group By방식도 알아둘 필요가 있다.(해싱 알고리즘)
4. Sort Unique
5. Sort Join - 소트 머지 조인을 하게 될때 사용된다.
6. Window Sort

## **5.2 소트가 발생하지 않도록 SQL 작성**

- 먼저 Union, Minus, Distict 연산자는 꼭 필요할 때만 사용하게 한다.

### 5.2.1 Union vs Union All

- Union을 사용하게 되면 두 집합간 중복을 제거하기 위해 소트 시킨다.
- 반면, UnionAll의 경우 중복확인 없이 단순 결합한다. → 소트 연산을 피할 수 있음.
- 인스턴스 중복 가능성을 확인하여, 있다면 → Union, 없다면 → UnionAll을 사용할 수 있다.

<aside>
🔥 소트연산이 일어나지 않도록 UnionAll을 사요하려면 다음과 같은 조건절을 추가한다.
and 결제일자 <> ‘20180316’ 혹은 and LNNVL(결재일자 = ‘20180316’)

</aside>

### 5.2.2 Exists 활용

- Distict 연산자는 해당 데이터를 모두 읽어 중복을 제거하기 때문에 많은 I/O가 발생한다.
- Exists()를 활용하여 데이터의 존재여부만 확인할 수 있다.

### 5.2.3 조인 방식의 변경

- 소트연산을 생략하는 방법으로 조인방식도 잘 선택하여 주어야 한다.

```sql
-- 인덱스가 [지점ID + 계약일시] 라고 한다면 -- 
selec ...
from 계약 c, 상품 p
where c.지점ID = brch+id
and p.상품코드 = c.상품코드
order by c.계약일시 desc
-- /* leading(c) use_nl(p) */ --
-- 계약 테이블 기준 NL 조인 하도록 조인 방식을 변경함으로써 소트연산을 생략할 수 있다. --
-- 지점 ID조건을 많족하는 데이터가 많고 부분범위 처리가 가능한 상황이라면 성능이 크게 개선 -- 
```

---

## 5.3 인덱스를 이용한 소트 연산의 생략

- 인덱스는 항상 키 칼럼 순으로 정렬된 상태를 유지한다.  → 이를 통한 소트 연산의 생략

### 5.3.1 Sort Order By 생략

다음 코드를 확인하라

```sql
select 거래일시, 체결건수 ...
from 종목거래
where 종목코드 = 'KR123456'
order by 거래일시
```

- 위 쿼리문에서 [종목코드 + 거래일시]의 인덱스가 있다면 옵티마이저에 의해 Order by는 생략될 수 있음을 기억하자.
    - 그렇다면 부분범위 처리를 활용한 튜닝기법은 아직도 유효할까?
    → 앞쪽 일부 우선 전송 후 클라이언트로부터 추가 요청이 있을 경우에 따라 나머지를 나눠 전송하는 방식인데, 3-Tier(DB와 클라이언트 사이 WAS,AP가 존재가능) 환경에서는 DB 커넥션을 반환해야 하므로 결과를 모두 전송해야 된다.
        - 당연히 유효하다 5.3.2절에서 공부할 Top N 쿼리가 그 주인공이다.

### 5.3.2 Top N 쿼리

- Top N 쿼리 → 상위 N 개만 선택하는 쿼리. (#select TOP 10 거래일시 … from 종목거래 …)
- 우리는 이 Top N Stopkey 알고리즘으로 불리는 스킬을 가지고 페이징 처리를 할 것이다.

```sql
select * from (
	select rownum no, a.*
	from (/* SQL Body */) a
	where rownum <= (:page*10)
)
where no >= (:page-1)*10+1
```

- 3-Tier 환경에서의 부분처리를 위해 우리의 할일은 다음과 같다.
1. 부분범위 처리가 가능하도록 SQL 작성
2. 작성한(테스트된) 부분처리용 SQL을 Body 안에 작성.
→ 인덱스 사용 가능하도록 조건절 구사하고, 조인은 NL조인 위주로 처리하고, Order By절이 있어도 소트 연산을 생략할 정도로 인덱스를 구성하는 것을 말한다.

---

### 5.3.3 최소값/최대값 구하기

- 인덱스는 정렬되어 있으므로, 왼쪽 1첫번째 → 최소값, 오른쪽마지막 값→ 최대값으로 볼 수 있다.

---

### 5.3.5 Sort Group By 생략

- 그룹핑 연산에서도 인덱스를 사용할 수 있다.
    - Nosort 연산 방식으로 Group By 처리.

---

## 5.4 sort Area를 적게 사용하도록 SQL을 작성한다.

- 소트 연산이 불가피 하다면! → 메모리 내에서 처리할 수 있도록 해야한다.

### 5.4.2  Top N  쿼리의 소트 부하 경감의 원리.

- Top N 쿼리에 소트 연산을 생략할 수 있도록 인덱스를 구성했을 때, 우리는 Top N StopKey 알고리즘을 보았다.
- Top N 소트 알고리즘이 소트 연산 횟수와 Sort Area 사용량을 줄여준다.

---