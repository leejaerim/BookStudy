# [SQL 처리 과정과 I/O]

### 1.1 SQL파싱과 최적화

- SQL은 구조적 질의 언어다. 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 과정은 절차적이다.
- 여기서 사용자의 SQL을 프로시저로 만들어주는 DBMS 내부 엔진이 바로 **SQL 옵티마이저**
- 옵티마이저가 프로시저를 작성하고 컴파일해서 실행가능한 상태로 만드는 전 과정을 **SQL 최적화**
1. 파싱
- 파싱트리를 생성하며, Syntax체크(*문법적오류) 및 Semantic 체크(**의미상 오류)
2. 최적화
3. 로우 소스 생성
- SQL옵티마이저는 최저비용 계산하여 최적의 실행계획을 선택함

<aside>
📌 자주 사용하는 힌트목록 정리해볼것

</aside>

---

### 1.2 SQL 공유 및 재사용

- 소프트파싱 vs 하드 파싱
- 내부 프로시저를 반복 재사용할수 있게 캐싱해두는 메모리공간을 **라이브러리 캐시**
- 라이브러리캐시에서 해당 SQL을 찾아 바로 실행단계로 넘어가면 소프트파싱, 그렇지 않다면 하드파싱(최적화&로우소스 생성)
- 바인드 변수의 필요성 → 각 변수마다 프로시저를 생성하게 되면 불필요하게 중복되는 SQL문이 많아지고, 이는 DBMS에서의 성능문제를 야기한다. 다음과 같이 바인드변수 프로시저를 생성해서 해결할 수 있다.
**create procedure LOGIN (login_id in varchar2) {…}**

<aside>
📌 String SQLStmt = “SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?”

</aside>

---

### 1.3 데이터 저장 구조 및 I/O 메커니즘

- 기본적으로 느린 이유는 I/O때문, I/O메커니즘을 이해하기 위하여 DB의 저장구조를 파악할 필요가 있다.
- 데이터베이스 저장구조
- 데이터파일(물리적디스크) →테이블스페이스 → 세그먼트(테이블, 저장공간이필요한 오브젝트) → 익스텐트(공간확장단위,연속된블록집합) → 블록(데이터를 읽고 쓰는 단위) → 로우
- 블록단위 I/O - 1Byte의 칼럼만 읽고 싶어도 블록 단위로 읽어야 함.
show parameter block_size
- 시퀀셜엑세스 vs 랜덤 액세스
- 시퀀셜 액세스 → 논리적 또는 물리적으로 연결된 순서에 따라 블록을 읽는 방식.
- 랜덤 액세스 → 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식입니다.
- **DB 버퍼캐시**가 존재. → DBMS시스템에서 데이터 캐싱 메커니즘은 필수
- 논리적블록 I/O와 물리적 블록 I/O의 차이. 물리적 블록의 입출력은 논리적(전기적) 블록 입출력에 비해 상당히 느리다.
- 그렇다면 버퍼캐시 히트율
- 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 메모리에서 찾은 경우,
- 물리적 입출력 = 논리적 입출력 * (100 - BCHR)
- 논리적 입출력을 줄이면 물리적 입출력도 줄어든다. 즉, 논리적 입출력을 줄임 으로써 물리적 입출력을 줄이는 것 “SQL 튜닝”

<aside>
📌 읽고자 하는 블록을 DB버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 입출력 CALL
→ 그동안 프로세스는 대기 큐

</aside>

- 멀티블록 입출력 - 디스크 상에서 찾으려는 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 적재

<aside>
💡 인덱스는  큰 테이블에서 아주 적은 일부테이터를 빨리 찾기 위한 도구일뿐, 맹신할 수 없다.

</aside>

- 메모리 공유자원에 대한 엑세스 직렬화
- 공유 메모리에 대한 2개 이상의 프로세스에서 동시에 접근하려고 할때 발생하며, 이를 순차적으로 접근할수있도록 직렬화 해야 한다. ⇒ 래치!

---