# [조인튜닝]

### NL 조인

- Nested Loops 조인 - 중첩 루프문 수행구조.
    - 인덱스를 이용한 조인 방식.
    - Inner쪽 테이블은 인덱스를 사용해야한다. (그렇지 않다면, Table Full Scan  하기 때문)
    - 사원 인덱스에서 입사일자를 기준으로 첫번째 레코드를 찾고, RowID를 사원 테이블 레코드를 찾는다.
    - 읽은 사원번호를 기준으로 고객테이블 인덱스에서 탐색한다.
    - 고객 인덱스에서 읽은 RowId를 기준으로 고객 테이블에서 테이블 레코드를 찾아간다.
- NL조인 특징
    - 랜덤 액세스 위주의 조인방식
    - 한 레코드씩 순차적으로 진행한다는 점.
    - 인덱스 구성 전략이 특히 중요하다.
    
    → 소량 데이터를 주로 처리하거나 부분 범위 처리가 가능한 온라인 트랜젝션 처리(OLTP)시스템에 적합한 방식
    
    ---
    

### 소트 머지 조인

- 조인컬럼에 인덱스가 없을 때, 대량 데이터 조인으로 인덱스가 효과적이지 않을때 → 옵티마이저는 해시 조인 or 소트 머지 조인을 사용한다.
- 그전에 SGA와 PGA를 복습하고 간다.
    - 공유메모리 영역 SGA - 여러 프로세스 공유가능하지만, 동시 액세스는 불가. 동시 액세스 프로세스의 직렬화하기 위한 Lock 메커니즘으로 래치가 존재한다. 데이터 블록 + 인덱스 블록을 캐시하는 DB 버퍼캐시로 구성. (+ 버퍼 Lock)
    - 이와 반대로, PGA는 프로세스(혹은 프로그램)에 할당된 고유 메모리다.PGA가 작을경우 temp라는 공유 테이블 스페이스를 사용한다.
    - PGA는 SGA와 다르게 래치 메커니즘이 불필요해서, SGA 버퍼캐시에서 읽을 때 보다 훨씬 빠르다.
    - PGA 오라클에서의 활용에 대해 알아보고자 한다.
- 소트 단계와 머지 단계로 구성.

```sql
SELECT /*+ orederd use_merge(c) */ 
	e.사원번호, e.사원명, e.입사일자,
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'z123'
and c.최종주문금액 >= 200000
```

- 사원 데이터를 읽어 조인칼럼인 사원번호 순으로 정렬 → 정렬된 결과집합을 PGA영역에 sort Area에 저장 *(혹은 temp 테이블 스페이스)
- 마찬가지로 조인칼럼인 관리사원번호순으로 정렬된 고객데이터를 PGA영역의 sort Area *(혹은 temp table space)에 저장
- 소트 단계
- PGA에 저장된 사원데이터를 스캔하면서 고객데이터와 조인한다.
- 머지 단계
- ordered 의 힌트는 From절에 기술한 순서대로 조인하라는 힌트이며, use_merge(c)의 경우 소트머지 방식으로 조인하라는 힌트이다. 옵티마이저는 정렬된 사원을 기준으로 정렬된 고객과 조인하게 된다.
- 사원 데이터 기준으로 고객 데이터를 매번 Full Scan하지 않는다. 정렬된 고객 데이터를 기준으로 조인에 실패하는 레코드를 만나면 바로 멈출 수 있게 된다.
- NL조인이 단적으로 인덱스를 이용한 조인방식으로 대량 데이터의 조인시 성능이 느리다는 단점이 있다.
→ 조인 과정에서 액세스 하는 모든 블록을 랜덤액세스 방식으로 일일히 DB버퍼캐시를 경유해서 읽는다. 버퍼캐시에서 읽지 못한 블록은 디스크에서 읽게되며, 인덱스의 한계가 그대로 있다.
→ PGA에 정렬된 데이터를 별도의 래치 획득과정없이 독립된 메모리 공간임으로 대량 데이터 조인에 NL조인 보다 유리하다.
- 사용 용도 
1. 조인 조건식이 등치조건이 아닌 대량데이터 조인
2. 조인조건식이 아예 없는 조인*(카테시안 곱)
- 스캔 위주의 액세스 방식을 사용하지만, 양쪽 소스 집합으로부터 조인 대상 레코드를 찾을 때 인덱스를 이용할 수 있고 이 때, 랜덤 액세스가 일어날 수도 있다.

---

### 해시 조인