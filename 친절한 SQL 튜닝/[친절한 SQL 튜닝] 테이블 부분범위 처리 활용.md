# [테이블 부분범위 처리 활용]

<aside>
💡 본절은 부분범위 처리 원리와 이를 활용한 성능향상을 이해 및 확인한다.

</aside>

- 자바 메소드에서 쿼리를 실행한다 하더라도,(아주 많은 테이블 레코드를 호출했을 때), DBMS는 한번에 전송하는 것이 아닌, 일정량(Window Size)를 전송하고 멈추기 때문이다.
→ 일정량 나누어 처리하는 방식을 부분범위 처리 라고 한다.
(아주 잘 생각해보면, 디비버를 이용한 데이터베이스에서 select처리도 100레코드 정도만 먼저 읽어온다.
- 그렇다면 order by를 추가하여 정렬된 데이터를 전송받고자 하면 어떻게 될까?
→ 모든 데이터들을 다 읽어들여, 정렬하고 나서 데이터를 전송할 수 있다.
    - 이처럼 소트 연산이 되지 않고 부분처리 가능하다면, 우리는 거의 실시간으로 데이터(Window Size)만큼의 데이터를 입력 받아 와, 처리해 줄수 있다.

---

### 인덱스의 선행컬럼이 조건절에 없다는 것은 아주 중요하다. *(스캔 효율을 매우 떨어뜨린다.)

→즉, 비효율적이다. 

- 우리는 SQL 트레이스를 사용해 효율을 알수 있다.

---

### 액세스 조건과 필터 조건

- 그림3-29를 참조하여 생각하여 보면, C1, C2는 인덱스 액세스 조건이며, C4는 인덱스 필터 조건이다.
- 테이블 액세스 단계에서 처리되는 조건절은 모두 테이블 필터 조건으로 볼 수 있다.
- 즉, 인덱스 액세스 조건은 인덱스스캔범위를 결정하는 조건절, 수직적 탐색의 스캔시작점을 결정하며, 어디서 멈출지까지 결정하는데 영향을 미친다. 이와 반대로 인덱스 필터 조건은 테이블로 액세스 할지 결정하는 조건절이다.

<aside>
💡 범위조건까지만 만족하는 인덱스 레코드는 모두 모여있지만, 그 이하 조건까지의 레코드는 흩어져있다.

</aside>

- 그렇기때문에 인덱스 선행 컬럼이 등치(=)조건일때 가장 효율적이다.
- Between보다 In-List로 구성하여 비록 인덱스를 여러번 호출한다고 하지만, 정작 읽어들이는 레코드는 많지않다.(단, In-List의 요소가 너무 많지 않아야 한다.)

---

<aside>
💡 인덱스 범위검색 조건을 남용하게 되면, 인덱스 스캔이 비효율적일 수 있다.

</aside>

- Like/Between 패턴을 사용하고자 한다면, 아래의 4가지 경우에 속하는지 확인한다.
1. 인덱스 선두 컬럼
2. Null 허용 컬럼
 - 성능을 떠나 결과집합에 오류가 생김.
3. 숫자형 컬럼
 - 자동형변환 이슈가 있다.
4. 가변 길이 컬럼
    - 인덱스 선두 컬럼에 라이크나, 비트윈연산자 처리는 금물이다.
- ibatis(SQL 매핑 프레임워크)와 같은 Dynamic SQL을 사용하게 되면 옵션조건에 = 연산자를 사용할 수 있다.