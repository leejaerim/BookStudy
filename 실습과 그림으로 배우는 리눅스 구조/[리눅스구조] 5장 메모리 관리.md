# [5장] 메모리 관리

> 리눅스 `free` 명령어는 메모리 내역을 확인 할 수 있습니다.
> 
- 메모리가 부족하면 커널 내부의 해제 가능한 메모리 영역을 해제 합니다.
    - 그럼에도 불구, 계속해서 메모리가 증가하면 OOM(out of memory)가 발생합니다.
- 메모리의 할당
    - 프로세스를 생성할 때
    - 동적 메모리를 할당할 때 `nmap()`
        - 프로세스가 메모리를 할당 요청하면, 커널은 메모리 할당 시스템콜을 호출합니다.
- 메모리 할당 방법의 문제
    - ***메모리 단편화(fragmentation)***
        - 실제로 빈 메모리 공간이 있음에도 불구하고, 요청한 사이즈의 빈공간이 없어 할당할 수 없는 문제.
    - 다른 프로세스의 메모리 접근가능 이슈
        - 프로세스에서 악의적으로 커널이나 다른 프로세스로의 메모리 접근이 가능.
    - 여러 프로세스의 핸들링 이슈

### ***가상메모리***

- 커널 메모리(물리메모리)를 직접 접근하지 않고, 가상주소를 사용하여 간접적으로 접근합니다.
- 페이지 테이블(가상주소에서 물리주소로 변환하는 테이블)
    - 쉽게 물리주소와 가상주소의 매핑 테이블 입니다.
    - 물리주소에 할당되지 않은 가상주소에 접근을 요청하면 `페이지 폴트(page fault)` 인터럽트가 발생합니다.

### 메모리의 할당

- 실행파일에서 프로그램의 실행파일을 읽어 메타데이터를 얻습니다.(오프셋, 사이즈, 시작주소 등등)
    - 실행파일 : 보조정보 + 코드 + 데이터
- 가상주소를 만들어 물리정보와 매핑 by 커널
- 이 후 페이지테이블에 작성하여 가상주소를 프로세스에 반환합니다.
- 가상 메모리를 통해 메모리 단편화 (`fragmentation`) 해결
- 커널모드가 아닌 사용자모드에서는 가상주소를 벗어난 다른 프로세스의 메모리로 접근이 불가능함.
- 다른 프로세스와 메모리가 겹칠 일이 없기 때문에(가상주소로 인해) 다중 프로세스 핸들링 이슈가 없음.

---

## 가상메모리의 응용

- 파일맵
    
    > 파일 접근 시스템 콜 : `read(), write(), lseek()`
    > 
    - 저장 장치에서 메모리로 파일을 복사한 뒤, 가상주소공간에 프로세스의 메모리와 파일의 복사메모리를 기록합니다.
    - 가상 주소 공간 = 프로세스 메모리(물리) + 파일의 복사 메모리(물리)
        - 프로세스가 특정 가상주소 100에 접근하여 `write()` 한다면 →  매핑된 파일의 복사메모리에 가서 쓰기를 기록합니다.
- 디멘트 페이징
    - 커다란 프로세스에서 가상메모리를 할당 해둔 뒤, 실제로 사용되지 않는 물리 메모리를 매핑 사용하고 있다면, 비효율적일 것 입니다. ⇒ 디멘트 페이징 방식을 채택.
    - 프로세스의 생성 직후, 가상주소로의 접근이 있을 때, 물리주소가 매핑되지 않았다면(할당되지 않았다면) 그 순간에 페이지폴트를 발생시키고, 페이지폴트 핸들러가 물리메모리를 할당하고 페이지폴트를 정리합니다.
    - 즉, 가상주소를 사용할 때 물리 매핑이 되지 않았으면, 페이지폴트 핸들러가 해당 페이지폴트를 처리합니다. ***따라서 실제로 가상주소에 접근할 때만, 물리주소를 매핑하는 것처럼 보여질 수 있습니다.***
    
    <aside>
    📌 가상 메모리 영역을 확보해도, 그 영역에 실제로 접근할 때까지는 물리 메모리 사용량은 거의 변화가 없습니다.
    
    </aside>
    
    - 가상 메모리의 부족
        - x86 → 4g , x86_64 → 128t 의 가상메모리를 가지고 있어 64비트의 경우 가상메모리 부족이 거의 없다.
- Copy on Write
    - `fork()` 를 통해 자식 프로세스를 생성할 때, 공유 메모리로 쓰기권한을 제한한 뒤, 동일한 페이지 테이블로 가상주소와 물리주소를 매핑합니다.
    - ***이 후 각 프로세스에서 해당 가상주소를 변경하려고 할때(쓰려고 할때), 페이지폴트를 발생시키고, 핸들러가 새로운 물리주소를 할당한 뒤 쓰기 권한을 업데이트 합니다. (= 페이지 공유 해제)***
    - 따라서 자식프로세스를 `fork()`할 때, 쓰기 접근이 없다면 가상메모리, 물리메모리는 복사하여 그대로 사용할 수 있고,불필요한 가상, 물리 메모리 절약도 가능합니다.
    
    > 참고 : 부모 프로세스로부터 생성된 자식프로세스는 많은 읽기 위주의 Cow 되어 있습니다. 따라서 프로세스 전체 물리 메모리는 당연히 실제로 쓰고 있는 메모리보다 더 큰 값입니다.
    > 
- 스왑
    - 물리메모리 부족(`OOM`)이 발생하면, 가상 메모리 방식을 응용한 스윕기능이 존재.
    - ***저장장치의 일부를 일시적으로 메모리로 사용하는 방식***
    - 물리 메모리가 부족하여 페이지 폴트가 발생하면, 스왑아웃 알고리즘을 거쳐, `한동안 사용되지 않을` 물리주소를 스왑영역(저장장치)의 주소 일부에 저장합니다.
    - 이 후, 프로세스A의 스왑아웃된 영역의 주소로 접근하면, 스왑영역에 임시 저장했던 메모리를 되돌립니다.(빈공간에 재할당) ⇒ 이를 스왑 인 이라고 하며, 스와핑(스왑아웃 + 스왑인)
    
    <aside>
    📌 저장장치의 접근속도는 메모리에 비해 너무 느리기 때문에, 메모리 부족이 만연하여 스와핑이 지속적으로 발생된다면, 쓰래싱 `thrashing`  상태가 됩니다.
    
    </aside>
    
- 계층형 페이지 테이블
    - 가상 메모리의 양에 따라 페이지 테이블을 계층화해서 사용합니다.
    - 페이지 테이블을 저장할 물리 메모리도 존재하는데, 다계층 구조를 두어서 메모리를 절약합니다.
- huge page
    - 가상메모리 사용이 증가하면 프로세스 테이블 페이지에 사용하는 물리 메모리양도 증가합니다.
    - 말그대로 페이지테이블의 가상주소를 넓게 가지면, 2단으로도 충분히 넓은 가상메모리 매핑이 가능합니다.

---