# [6장] 메모리 계층

### 목표

- 메모리는 레지스터 → 캐시 메모리 → 메모리 →  저장장치로 나뉩니다.
- 리눅스에서 어떻게 메모리 계층을 이루고 있는지 공부합니다.

---

1. 캐시 메모리는 일반적으로 cpu 내부와 외부에 존재합니다.
    - 레지스터와 메모리간 속도 차의 병목현상을 방지하기 위해 존재합니다. (레이턴시 상쇄)
    - 메모리에서 데이터를 로드해, 캐시메모리에 복사합니다. → 이후 CPU에서 해당 주소를 재탐색하는 경우, cache메모리에서 데이터를 로드하게 됩니다.
    - 캐시메모리가 가득찬 경우, 기존의 캐시 메모리를 파기하며, 새로 저장하는데 파기 대상의 캐시가 더티면, 메모리를 덮어쓴 다음 버리는 동기화 작업이 이루어집니다.
    - 계층형 캐시메모리 → L1 , L2, L3등 이름이 존재하며, 1에 가까울수록 CPU에 가깝습니다.
    - 메모리 참조의 국소성
        1. 시간 국소성
        2. 공간 국소성

<aside>
📌 프로그램의 성능을 높히려면, 캐시 메모리 사이즈 내에서 프로그램이 동작하도록 합니다.
데이터의 자료구조나 알고리즘을 단위시간당 메모리 접근 범위를 작게 하는 것이 중요합니다.

</aside>

---

1. 페이지 캐시
    - 저장장치에 접근하는 속도는 매우 느리기 때문에 커널에서는 페이지 캐시 기능을 제공
    - 저장 장치 내의 파일테이터를 ***메모리에 캐싱***한 것.
    - 캐시메모리의 캐시 라인 단위 처럼, ***페이지 단위로 데이터***를 다룹니다.

<aside>
📌 파일의 데이터가 페이지 캐시에 존재한다면, 
미리 저장된 프로세스 메모리를 참조해 파일접근이 빨라질 수 있습니다.

</aside>

---

### 정리

- 레지스터와 메모리간 레이턴시를 제거하기 위해, 중간에 캐시메모리를 둔다.
- 마찬가지로 메모리와 저장장치사이에서의 레이턴시 제거를 위해, 커널 수준에서 메모리에 페이지 캐시를 둡니다.
- 쓰기의 경우엔 `더티` 라는 플래그를 두어, 캐시메모리, 페이지캐시를 먼저 업데이트하고 읽은 후, 커널 백그라운드 수준에서 메모리와 저장장치의 동기화를 진행합니다.(이 때의 `더티` 플래그는 제거됩니다.)

---