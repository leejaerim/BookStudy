# [4강] 85강 거침없이 자바스크립트

### Sequential Async

```jsx
const render = function(...urls){
	Promise.all(urls.map(url=>fetch(url,{method}....
}
const render = function(...urls){
	const loop =_={
		if(urls.length){
			fetch(urls.shift(), {method:"GET"}).then(res=>res.json()).then(json=>{
				console.log(json);
				loop()
			});
		}
	}
	loop();
}
render("1.json","2.json","3.json");
```

### Generator & Executor

- dataLoader 분기했어도 함수로 호출해서 랜더링할 뿐이다.
- 프로미스를 리턴하고 있고, 외부에서 제어(위임) , 데이터로더를 수정할 가능성을 줄여버린다.
- 제어를 처리하는 부분과 제어를 처리하는 부분

```jsx
const dataLoader = function*(f,...urls){//Generator
	for(const url of urls){
		const json = yield fetch(url,{method:"GET"}).then(res=>res.json());
		f(json);
	}
};
const render = function(...urls){
	const iter = dataLoader(console.log,...urls);
	const next = ({value,done})=>{
		if(!done)value.then(v=>next(iter.next(v)));	
	};
	next(iter.next());
};
render("1.json","2.json","3.json");
```

- dataLoader는 제네레이터 맵으로 볼 수 있다.
- 외부 제어가 비동기를 할 줄 알아서 성립한다. 비동기를 캡슐화 해서 넘겨줬고, 외부제어쪽에서 처리
- 프로미스 객체를 주고 then을 외부제어에서 호출될 때 가장 큰 강점을 갖는다.

---

- 데이터로더 함수는 f 함수를 통해서 데이터 처리 및 프로미스 객체 반환 두가지 작업을 하게 되고 우리는 하나의 함수는 하나의 책임을 진다는 원칙에 의해 수정할 필요성을 갖는다.
- 수정된 함수는 다음과 같다.

```jsx
const dataloader = function(...urls){
	for(const url of urls){
		const json = yield fetch(url,{method:"GET"}).then(res=>res.json());
		yield json;
	}
}//비동기 처리도 값처리도 yield를 구분할 필요가 있다.
...
const next = ({value,done})=>{
	if(!done){
		if(value instanceof Promise) value.then(v=>next(iter.next(v)));
		else{
			console.log(value);//데이터처리를 다시 랜더링으로 다시 넘어오게 만들었다.
			next(iter.next());
		}
	}
}//dataloader는 순수히 데이터로드하는 역할, 즉 Promise를 통한 제어권을 넘겨주는 역할만 한다.
```

### Async Iterator

```jsx
const render = async function(...urls){
	for(const url of urls){
		console.log(await(await fetch(url,{method:"GET"})).json())
	}
}
```

- Promise.then을 단축표현한 것이 바로 await 이다.
- 제어, 랜더 전부 들어가 있음.

```jsx
const dataLoader = async function*(...urls){
	for(const url of urls){
		yield await(await fetch(url,{method:"GET"})).json();
	}
}//åsync Generator
const render = async function(...urls){
	for await(const json of dataLoader(...urls)){
		console.log(json)
	}
}//마찬가지로 async이여야지만 async Generator를 사용할 수 있다.
//async iterator(프로미스가 존재)
```

---

### Async yield*

- 서스펜드의 연쇄 다중 뎁스를 지원하는 대표적인 문법이 async yield*

```jsx
const urlLoader = async function*(url){
	yield await(await fetch(url, {method:"GET"})).json();
}
const dataLoader = async function*(...urls){
	for(const url of urls) yield* urlLoader(url);
}
const render = async function(...urls){
	for await(const json of dataLoader(...urls){
		console.log(json)
	}
}
```

- urlLoader를 dataloader에서 제어하고자 한다.
- 서브이터러블을 외부 이터러블로 빼주는 작업.

---