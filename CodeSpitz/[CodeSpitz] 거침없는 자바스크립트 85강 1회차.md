# [거침없는 자바스크립트 85강 1회차]

### 런타임

- 컴파일 이후 파일 → 메모리에 적재(Loading) → 메모리에 값과 명령으로
- CPU에서 (제어+연산+레지스터), 여기서 인스트럭션(CPU가 해석 할 수 있는 명령)
- 메모리에 적재된 명령들이 순차적으로 패칭과 디코딩 과정을 통해 실제 명령으로 해석하여 연산유닛에서 실행한다.
- <폰 노이만 머신 구조>
- sync flow : 로딩된 명령어와 값을 통해 패칭 및 실행 단계가 반복되는 것을 의미
- 컴파일러가 가상 메모리를 두어서 구동. → vtable mapping

---

### State Control

- 메모리에 있는 값을 밸류가 아닌 스테이트라고 한다. 늘 변화하기 때문이다.
- 변수 → 메모리 영역의 별칭으로 볼수도 있다.

```sql
b = &a
c = &b 라고 하면 b의 주소값을 가져올것같지만, b가 가르키는 a의 주소값을 가르킨다.
직접 참조하면 참조가 오픈된 순간 변경할 수 없는 제약조건이 생기며, "전파"가 일어날 수 있다.
한번더 참조의 공개 안정성. -> 간접적인 참조
(런타임에 추가적인 연산을 통하여, 한번 더 주소를 연산하게 되지만)
```

---

### Flow Control

- Sync flow →메모리에 적재된 명령이 순차적으로 실행됨.
- Sync flow control → Goto문을 통해 명령 위치의 이동 가능. 메모리의 State의 따라 컨트롤이 됨!
- Sub flow → 함수를 통해 별도의 명령셋을 여러번 실행한다.(함수의 형태) = 서브루틴.
- 코드의 배치 (조영호님의 오브젝트) →  필요에 의해 태어난 if문 조건 등을 어떻게 배치 할 것인가? 
→ 설계의 정의.. dip ioc 추상적인 사안에 의존, 좋은 설계.

---

### Blocking

- 폰노이만 구조(메모리에 적재)에서 싱크 플로우가 실행되는 동안 다른 일을 할 수 없는 현상
- 블록킹은 없을 수 없고, 줄일 수 있다. → 싱크플로우를 짧게 함으로써,
- 다른 쓰레드에 싱크플로우를 떠 넘긴다.
→ 작업이 완료되면, 메인 스레드에 완료 보고를 해야된다.
→ 이벤트루프*(다른 스레드의 작업을 기다린다. 예로 브라우저)
- 메인 스레드를 줄이고, 다른 스레드에 넘김으로서 중앙에서 제어하길 바람.
- 더 고차원적인 병행적 블록킹이 생긴다.

<aside>
💡 Non BLocking 싱크플로우가 납득할 만한 시간내에 종료되는 것.

</aside>

---

### Sync & Async

- Sync - 서브루틴이 즉시 값을 반환함. (현재의 메인 스레드에서 싱크 플로우 내에서 값을 반환)
- Async - 서브루틴이 다른 수단으로 값을 반환함. 메인 싱크플로우에서 벗어남
→ 여기서 다른 수단이란? Promise , Callback function, iterations
→ 단점 : 호출결과가 즉시 반환되지 않으므로 현재 싱크플로우가 종료, 그결과 상태를 결과 시점에 사용할 수 없고 따라서 별도의 결과시점에 전달할 부가 장치가 필요함.
- Sync의 장점 + Async의 장점 → Continuation.

---