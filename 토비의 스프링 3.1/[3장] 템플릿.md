# [3장] 템플릿

<aside>
📌 템플릿 : 변경이 일어나지 않는 부분과 일어나는 부분을 독립적으로 분리시켜 효과적으로 사용하고자 함.

</aside>

### 예외처리 기능을 갖춘 DAO

- 예외 처리 없이 에러가 나게되면, 리소스의 반납*close() 없이 구문이 종료된다.
→ 이는 장기적으로 보면 심각한 리소스 에러
- try&catch&finally 를 사용해본다.

```java
try{
	c= dataSource.getConnection();
	ps = c.prepareStatement("Delete from users");
	rs = ps.executeQuery();//SELECT 조회시.
	rs.next();
	ps.executeUpdate();
}catch(SQLException e){ throw e;}
finally{
	if(ps != null){
		try{ps.close();}catch(SQLException e){...}
	}
	if(c != null){
		try{c.close();}catch(SQLException e){...}
	}
	if(rs != null){
		try{rs.close();}catch(SQLException e){...}
	}
}
```

- 어느 시점에 에러가 났는지 확인할 수 없으니, ps와 c 모두에 대한 close를 호출해주어야 한다.
- ~~너무 지저분하다….~~

---

- 위에서 짠 코드의 문제점은 중복도 심하고 언제 어디서 문제가 될지 파악도 힘들다는 점이다.
- ***바로 여기서 변하는 점과 변하지 않는 점을 분리하는 템플릿 작업을 하게 된다.***
- 메소드의 추출 : 변하는 부분을 메서드로 추출.

```java
public void deleteAll() throws SQLException{
	try{
		c = dataSource.getConnection();
		ps = makeStatement(c);
		ps.executeUpdate();
	}catch(SQLException e){...}
}
private PreparedStatement makeStatement(Connection c) throws SQLException{
	PreparedStatement ps;
	ps = c.prepareStatement("Delete from users");
	return ps;
}
```

***→ 템플릿 메서드 패턴의 적용***

- 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상메서드로 정의해둬서 서브클래스에서 오버라이드해서 새롭게 정의하여 사용.

```java
public class UserDaoDeleteAll extends UserDao{
	protected PreparedStatement makeStatement(Connection c) throws SQLException{...}
}
```

- UserDao클래스의 기능을 확장하고 싶을때마다 상속을 통해 자유롭게 확장할 수 있고, OCP원칙도 준수한다.
- 단점
    - DAO로직마다 상속을 통해 새로운 클래스를 만들어야한다.

---

***→ 전략 패턴의 사용***

- OCP를 지키면서도 확장성과 유연성을 갖는 패턴
- 변하지 않는 부분을 contextMethod()로 두고, 특정 확장기능을 적절하게 별도의 클래스인 Strategy 객체의 인터페이스를 통해 구현.

```java
public interface StatementStrategy{
	PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
---
public class DeleteAllStatement implements StatementStrategy{
	public PreparedStatement makePreparedStatement(Connection c) throws SQLException{
	PreparedSatement ps = c.prepareSatement("delete from users");	
		return ps;
	}
}
---
// Called IN ContextMethod 
public void deleteAll() throws SQLException{
	...
	StatementStrategy strategy = new DeleteAllStatement();
	ps = strategy.makePreparedStatement();
	ps.executeUpdate();
}
```

- 단점 :  이렇게 컨텍스트 안에서 이미 구체적인 전략클래스가 선언되어 버리면 OCP도 유연성도 상실되기 마련이다.
- 그래서 어느 전략클래스를 사용하게 될지는 클라이언트까지 밀어낸다. 최대한.
- ***DI란, 결국 이러한 전략패턴의 장점을 일반적으로 활용할 수 있는 구조.***
- 컨텍스트를 분리한 메서드 코드

```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException{
	...
	ps = stmt.makePreparedStatement(c);
	...
}
```

- 분리된 컨텍스트를 클라이언트 책임을 담당할 deleteAll() 메서드

```java
public void deleteAll(){
	//전략클래스의 오브젝트 생성
	StatementStrategy stmt = new DeleteAllStatement();
	//전략오브젝트의 전달 컨텍스트 호출
	jdbcContextWithStatementStrategy(st);
}
```

---

### JDBC 전략 패턴의 최적화

- 이렇게 `jdbcContextWithStatementStrategy` 와 `interface를 implements한 StatementStrategy` 을 이용해서 JDBC Context를 최적화할 수 있었다.
- 추가적인 개선점
1. DAO메서드마다 새로운 전략 구현 클래스를 만들어야 한다.
2. 전략클래스에 전달한 부가정보가 있을 경우, 추가적인 인스턴스를 만들어서 주입해야 된다.
- 전략클래스의 ***내부 로컬클래스***로 만들어버린다. → UserDAO 에서만 사용가능한 로컬클래스
- 자신이 선언된 곳의 정보를 접근도 할수있다.

```java
public void add(final User user) throws SQLException{
	class AddStatement implements StatementStrategy{
		...
		ps.setString(1, user.getId())//로컬클래스의 코드에서 외부메서드의 로컬변수에 직접 접근가능
		...
	}
	StatementStrategy st = new AddStatement();
	jdbcContextWithStatementStrategy(st);
}
```

- ***익명 내부 클래스***

```java
public void add(final User user) throws SQLException{
	jdbcContextWithStatementStrategy({
		new StatementStrategy(){
			public PreparedStatement makePreparedStatement(Connection c) throws SQLException{
				...
				return ps;
			}
		}
	}
}
```

---

### 3.4 컨텍스트와 DI

- jdbccontext 를 분리시켜 모든 DAO에서 사용할 수 있도록 하자.

```java
public class jdbcContext{
	private DataSource dataSource;
	public void setDataSource(DataSource dataSource){...}
	public void workWithStatementStrategy(StatementStrategy stmt) throws SQLExcetion{
		Connection c =null;
		PreparedStatement ps = null;
		try{
			c = this.dataSource.getConnection();
			ps = stmt.makePreparedStatement(c);
			ps.executeUpdate();
		}catch(SQLExcpetion e){ throw e;}
		finally{...}
	}
}
public class UserDao{
	private JdbcContext jdbcContext;
	public void setJdbcContext(...){...}
	public void add(final User user){
		this.jdbcContext.workWithStatementStrategy(
			new StatementStrategy(){...}
		)
	}
}
```

- 빈 의존관계 변경