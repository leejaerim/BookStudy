# [프롤로그 & 1장] 스프링

<aside>
📌 스프링의 정의 역할에 대해 공부 합니다.

</aside>

### 스프링이란?

- 앱 `프레임워크`
    - 스프링컨테이너 , IOC/DI, 서비스 추상화, AOP , 기술 API
    - 이 세가지의 요소의 적절한 활용한 앱 개발 제공
- 2가지 가치
    - 단순함 - 복잡한 객체지향언어의 단순화하여 객체지향의 특징을 극대화(POJO)
    - 유연성(확장성) - 다른 프레임워크와 편리하게 접목되서 사용가능

---

# 1장  오브젝트와 의존관계

<aside>
📌 자바를 기반으로 한 스프링을 배우기에 앞서, 자바의 핵심인 객체 지향에 대해 공부합니다.

</aside>

### 1.1 초난감 DAO

- `DAO(Data Access Obejct`
- DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

```
자바빈
- 디폴트 생성자 : 파라미터가 없는 디폴트 생성자를 갖고 있어야 함
- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성
```

### 1.1.2 UserDao

```java
public class UserDao{
	pulbic void add(User user) throws ... {
		...
		PreparedStatement ps = connection.prepareStatement(
		"Insert into users(id,name,password) values( ? , ? , ? );
		ps.setString(1,user.getId())
		ps.setString(2,user.getName())
		ps.setString(3,user.getPassword())
		ps.executeUpdate();
		ps.close();
		connection.close();
	}
	public User get(String id) throw...{
		...
		Result rs = ps.executeQuery();
		rs.next()
		...
	}
}
```

---

### 1.2 DAO의 분리

- 관심사의 분리 : ***변화와 확장을 고려한 설계***
    - 상기 1.1.2 에서 다루었던 DAO는 그런 점에서 잘못된 설계라고 볼 수 있다. (중복 코드의 제거)

```java
private Connection getConnection() throw ...{
	Class.forName("com.mysql.jdbc.Driver")
	Connection c = DriverManager.getConnection(...)
	return c
}
```

- 위 작업은 DAO를 변경하지 않았지만, Connection을 선언하는 중복 코드를 제거 함으로써 확장에 열려있게 만들었다.
- 이렇게 기능의 변화는 없지만 변화에 손쉽게 대응할 수 있도록 코드를 변경하는 것을 ***리팩토링*** 이라고 한다.

---

### 1.2.3 DB 커넥션 만들기의 독립

- 상속을 통한 확장

```java
public abstract class UserDao{
	//...생략
	public abstract Connection getConnection() throw ...;
	//자식클래스에서 구현
}
```

- 슈퍼클래스에 기본적인 로직의 흐름(기능)을 만들고 , 그 기능의 일부를 추상메소드나 오버라이딩이 가능한  protected 메소드 등으로 만든 뒤 서브클래스에서 이러한 메서드를 필요에 맞게 설계 → ***템플릿 메소드 패턴***
    - 훅을 만든 뒤, 슈퍼클래스에서 기능을 구현할때 훅을 쓰게 만들고 실제 훅은 서브클래스에서 구현하도록 한다. 또 이때의 ***서브 클래스는 훅 이외의 슈퍼클래스가 모르는 지식을 알고 있어서는 안된다.***
    - 변하지 않는 기능을 슈퍼클래스에 만들어두고(서브클래스에서 변경 X), 자주 변경되며 확장 가능한 기능을 서브클래스에서 구현
- 또 추가적으로 서브클래스에서 구체적인 오브젝트 생성방법을 결정하게 하는 것 →  ***팩토리 메서드 패턴***
- UserDao는 어떤 기능을 사용하는지만 관심있으며 어떻게 구현되는지 관심없다.

---

### 1.3 DAO의 확장

- 상속을 합성으로 변경

```java
public class UserDao{
	private SimpleConnectionMaker simpleConnectionMaker;
	public UserDao(){simpleConnectionMake = new SimpleConnectionMaker();}
...
}
```

- UserDao는 `SimpleConnectionMake` 라는 클래스에 종속적으로 되어 자유로운 확장이 불가능해졌다.
    
    → 인터페이스의 도입
    
    ```java
    public interface ConnectionMaker{
    	public Connection MakeConnection() throws...{ SQLException;}
    }
    public class DConnectionMaker implements COnnectionMaker(){
    	public Connection makeConnection(){...}
    }
    ```
    
- 그럼에도 불구하고 UserDao에서 `Connection c = new DConnectionMaker()` 로 UserDao가 `DconnectionMaker` 를 알고 있다.
***→ 파라미터를 통해 주입시켜준다.***

```java
...
UserDao dao = new UserDao(connectionMaker); // DI
```

---

### 1.3.4 원칙과 패턴

- SOLID 원칙
    - SRP - 단일책임
    - OCP - 개방폐쇄
    - LSP - 치스코프치환원칙
    - ISP - 인터페이스 분리 원칙
    - DIP - 의존관계 역전 원칙
- 응집도와 결합도
- 전략패턴 - UserDaoTest - UserDao - ConnectionMaker간의 관계를 보면 클라이언트(UserDaoTest)입장에서 사용할 ConnectionMaker를 적절하게 생성하여 UserDao에 주입시켜준다.

---